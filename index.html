<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KulaFlow Prompt Generator</title>
    <style>
        :root {
            --primary-color: #3498db;
            --primary-dark: #2980b9;
            --secondary-color: #2ecc71;
            --secondary-dark: #27ae60;
            --text-color: #2c3e50;
            --bg-light: #f9f9f9;
            --bg-medium: #ecf0f1;
            --border-color: #dfe6e9;
            --accent-color: #e74c3c;
            --shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            --radius: 8px;
            --mono-font: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            max-width: 850px;
            margin: 0 auto;
            padding: 25px;
            background-color: var(--bg-light);
        }
        
        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 35px;
            font-weight: 600;
            font-size: 32px;
        }
        
        h3 {
            color: var(--primary-dark);
            margin-bottom: 15px;
            font-weight: 500;
        }
        
        .section {
            margin-bottom: 30px;
            background-color: white;
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow);
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .section-title {
            font-weight: 500;
            color: var(--primary-dark);
            margin: 0;
        }
        
        .code-block {
            background-color: var(--bg-medium);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            font-family: var(--mono-font);
            white-space: pre-wrap;
            margin-bottom: 20px;
            position: relative;
            box-shadow: var(--shadow);
        }
        
        .code-block pre, 
        .code-block textarea {
            font-family: var(--mono-font);
            font-size: 14px;
        }
        
        .code-block textarea {
            width: 100%;
            min-height: 90px;
            border: none;
            background: transparent;
            resize: vertical;
            outline: none;
            overflow: auto;
        }
        
        .template-container {
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .prompt-preview-container {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .buttons-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .prompt-preview {
            flex-grow: 1;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 20px;
            background-color: white;
            box-shadow: var(--shadow);
            transition: box-shadow 0.2s;
            font-family: var(--mono-font);
            line-height: 1.7;
        }
        
        .action-btn {
            background-color: var(--bg-medium);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 8px 14px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-top: 8px;
            align-self: flex-end;
            transition: all 0.2s;
        }
        
        #add-wildcard-btn {
            position: absolute;
            bottom: 15px;
            right: 15px;
            margin-top: 0;
            background-color: var(--secondary-color);
            color: white;
            border-color: var(--secondary-dark);
        }
        
        #add-wildcard-btn:hover {
            background-color: var(--secondary-dark);
        }
        
        #randomize-btn {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-dark);
        }
        
        #randomize-btn:hover {
            background-color: var(--primary-dark);
        }
        
        .action-btn:hover {
            transform: translateY(-1px);
        }
        
        .folders-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .folder-item {
            display: flex;
            align-items: center;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px 12px;
        }
        
        .folder-name {
            margin-left: 8px;
            font-weight: 500;
            color: var(--primary-dark);
        }
        
        .folder-checkbox {
            margin-right: 5px;
        }
        
        .wildcards-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 25px;
        }
        
        .wildcard-badge {
            background-color: #e9f5ff;
            border: 1px solid #c5e1ff;
            border-radius: 20px;
            padding: 5px 14px;
            font-size: 14px;
            color: var(--primary-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            transition: all 0.2s;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .wildcard-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            background-color: #d4ebff;
        }
        
        .wildcard-badge[data-folder] {
            position: relative;
        }
        
        .wildcard-badge[data-folder]:before {
            content: attr(data-folder);
            position: absolute;
            top: -18px;
            left: 5px;
            font-size: 10px;
            color: var(--text-color);
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .wildcard-badge[data-folder]:hover:before {
            opacity: 1;
        }
        
        .template-selector-container {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .selector-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .template-selector {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background-color: white;
            font-size: 14px;
        }
        
        .template-navigation {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
        }
        
        .template-number {
            display: inline-block;
            min-width: 28px;
            height: 28px;
            line-height: 28px;
            text-align: center;
            background-color: var(--bg-medium);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .template-number:hover {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-dark);
            transform: translateY(-2px);
        }
        
        .template-number.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-dark);
            font-weight: bold;
        }
        
        .error-message {
            color: #e74c3c;
            font-size: 14px;
            padding: 8px;
            background-color: #fdeaea;
            border: 1px solid #f5c6cb;
            border-radius: var(--radius);
        }
        
        .success-message {
            color: #2ecc71;
            font-size: 14px;
            padding: 8px;
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: var(--radius);
        }
        
        .prompt-preview select {
            padding: 5px 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background-color: var(--bg-light);
            margin: 0 5px;
            font-size: 0.9em;
            cursor: pointer;
        }
        
        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius);
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: var(--shadow);
        }
        
        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .output-container {
            margin-top: 35px;
        }
        
        .btn-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
        }
        
        .action-btn-small {
            background-color: var(--bg-light);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-btn-small:hover {
            background-color: var(--bg-medium);
        }
        
        .hidden {
            display: none;
        }
        
        #output-text {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: var(--mono-font);
            margin: 0;
        }
    </style>
</head>
<body>
    <h1>KulaFlow Prompt Generator</h1>
    
    <div class="section">
        <div class="section-header">
            <h2 class="section-title">Available Wildcards</h2>
        </div>
        <div class="folders-container" id="folders-container">
            <!-- Folders will be added dynamically -->
        </div>
        <div class="wildcards-container" id="wildcards-container">
            <!-- Wildcard badges will be added dynamically -->
        </div>
    </div>
    
    <div class="section">
        <div class="section-header">
            <h2 class="section-title">Template Editor</h2>
        </div>
        <div class="template-selector-container">
            <div class="selector-group">
                <label for="template-selector">Template File:</label>
                <select id="template-selector" class="template-selector">
                    <option value="">-- Select Template --</option>
                    <!-- Template options will be added dynamically -->
                </select>
                <button id="debug-templates-btn" class="action-btn-small">Debug Templates</button>
            </div>
            <div id="template-navigation" class="template-navigation">
                <!-- Template navigation numbers will be added dynamically -->
            </div>
        </div>
        <div class="code-block template-container">
            <textarea id="template-input" placeholder="Enter your prompt template with [W] placeholders">a cute [W] in a [W], [W]</textarea>
            <button id="add-wildcard-btn" class="action-btn">Add Wildcard</button>
        </div>
    </div>
    
    <div class="section">
        <div class="section-header">
            <h2 class="section-title">Preview &amp; Variables</h2>
        </div>
        <div class="prompt-preview-container">
            <div class="prompt-preview" id="prompt-preview">
                <!-- Dynamic preview will be inserted here -->
            </div>
            <div class="buttons-container">
                <button id="randomize-btn" class="action-btn">Randomize</button>
                <button id="generate-btn" class="action-btn">Generate</button>
            </div>
        </div>
    </div>
    
    <div id="output-container" class="output-container hidden section">
        <div class="section-header">
            <h2 class="section-title">Generated Prompt</h2>
        </div>
        <div class="code-block" id="output-block">
            <pre id="output-text"></pre>
            <div class="btn-container">
                <button class="action-btn-small" id="copy-btn">Copy</button>
                <button class="action-btn-small" id="save-to-dayone-btn">Save to Day One</button>
            </div>
        </div>
    </div>
    
    <script>
        // Store the loaded wildcards data
        const wildcards = {};
        
        // Store the visibility state of folders
        const folderVisibility = {};
        
        // Function to load wildcard files
        async function loadWildcards() {
            try {
                const response = await fetch('/wildcards');
                const data = await response.json();
                
                // Initialize all folders as visible
                if (data.folders) {
                    Object.keys(data.folders).forEach(folder => {
                        folderVisibility[folder] = true;
                    });
                }
                
                // Display folders first
                displayFolders(data.folders || {});
                
                // Load root wildcards
                const rootLoadPromises = (data.files || []).map(async (file) => {
                    if (file.endsWith('.txt')) {
                        // Extract the name without the .txt extension
                        const name = file.replace('.txt', '');
                        console.log(`Loading root wildcard: ${file} -> name: ${name}`);
                        
                        const fileResponse = await fetch(`/wildcards/${file}`);
                        const text = await fileResponse.text();
                        const items = text.split('\n')
                            .map(line => line.trim())
                            .filter(line => line && !line.startsWith('#'));
                        
                        wildcards[name] = items;
                        return { name, count: items.length, folder: null };
                    }
                    return null;
                });
                
                // Load folder wildcards
                const folderLoadPromises = [];
                
                if (data.folders) {
                    Object.entries(data.folders).forEach(([folder, files]) => {
                        files.forEach(file => {
                            if (file.endsWith('.txt')) {
                                const name = file.replace('.txt', '');
                                console.log(`Loading folder wildcard: ${folder}/${file} -> name: ${name}`);
                                
                                const promise = fetch(`/wildcards/${folder}/${file}`)
                                    .then(response => response.text())
                                    .then(text => {
                                        const items = text.split('\n')
                                            .map(line => line.trim())
                                            .filter(line => line && !line.startsWith('#'));
                                        
                                        wildcards[name] = items;
                                        return { name, count: items.length, folder };
                                    })
                                    .catch(err => {
                                        console.error(`Error loading ${folder}/${file}:`, err);
                                        return null;
                                    });
                                
                                folderLoadPromises.push(promise);
                            }
                        });
                    });
                }
                
                // Wait for all wildcards to load
                const rootWildcards = (await Promise.all(rootLoadPromises)).filter(Boolean);
                const folderWildcards = (await Promise.all(folderLoadPromises)).filter(Boolean);
                
                // Combine and display all wildcards
                const allWildcards = [...rootWildcards, ...folderWildcards];
                displayWildcards(allWildcards);
                updatePromptPreview();
                
            } catch (error) {
                console.error('Error loading wildcards:', error);
                // Fallback: Load directly from known files if server endpoint fails
                loadWildcardsDirectly();
            }
        }
        
        // Fallback function to load wildcards directly
        async function loadWildcardsDirectly() {
            const knownWildcards = ['animals', 'weather', 'textures', 'woman'];
            
            const loadPromises = knownWildcards.map(async (name) => {
                try {
                    const fileResponse = await fetch(`/wildcards/${name}.txt`);
                    const text = await fileResponse.text();
                    const items = text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line && !line.startsWith('#'));
                    
                    wildcards[name] = items;
                    return { name, count: items.length, folder: null };
                } catch (err) {
                    console.error(`Error loading ${name}.txt:`, err);
                    return null;
                }
            });
            
            const loadedWildcards = (await Promise.all(loadPromises)).filter(Boolean);
            displayWildcards(loadedWildcards);
            updatePromptPreview();
        }
        
        // Display available folders with checkboxes
        function displayFolders(folders) {
            const container = document.getElementById('folders-container');
            container.innerHTML = '';
            
            Object.keys(folders).forEach(folderName => {
                const folderItem = document.createElement('div');
                folderItem.className = 'folder-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'folder-checkbox';
                checkbox.checked = folderVisibility[folderName];
                checkbox.dataset.folder = folderName;
                
                checkbox.addEventListener('change', () => {
                    // Update visibility state
                    folderVisibility[folderName] = checkbox.checked;
                    
                    // Update display of wildcard badges based on folder visibility
                    document.querySelectorAll(`.wildcard-badge[data-folder="${folderName}"]`).forEach(badge => {
                        badge.style.display = checkbox.checked ? 'flex' : 'none';
                    });
                });
                
                const label = document.createElement('span');
                label.className = 'folder-name';
                label.textContent = folderName;
                
                folderItem.appendChild(checkbox);
                folderItem.appendChild(label);
                container.appendChild(folderItem);
            });
        }
        
        // Display available wildcards as badges
        function displayWildcards(wildcardsList) {
            const container = document.getElementById('wildcards-container');
            container.innerHTML = '';
            
            wildcardsList.forEach(({ name, count, folder }) => {
                const badge = document.createElement('div');
                badge.className = 'wildcard-badge';
                badge.textContent = `${name} (${count})`;
                
                // Store the name directly on the badge element for easier access
                badge.dataset.wildcardName = name;
                
                // If this wildcard belongs to a folder, add a data attribute and apply visibility
                if (folder) {
                    badge.dataset.folder = folder;
                    badge.style.display = folderVisibility[folder] ? 'flex' : 'none';
                }
                
                // Make the badge clickable to add the wildcard to the template
                badge.addEventListener('click', function() {
                    // Add this specific wildcard to the template
                    const wildcardName = this.dataset.wildcardName;
                    console.log(`Clicked on wildcard badge: ${wildcardName}`);
                    
                    // Use a simplified direct approach
                    addSpecificWildcard(wildcardName);
                });
                
                container.appendChild(badge);
            });
        }
        
        // Simplified function specifically for adding a named wildcard
        function addSpecificWildcard(wildcardName) {
            console.log("addSpecificWildcard called with:", wildcardName);
            
            const templateInput = document.getElementById('template-input');
            const cursorPos = templateInput.selectionStart;
            const currentText = templateInput.value;
            
            // Create the wildcard text with the specific name
            const wildcardText = `[${wildcardName}]`;
            console.log("Wildcard text to insert:", wildcardText);
            
            // Format with commas based on position
            let insertText;
            if (cursorPos === 0) {
                insertText = wildcardText + ", ";
            } else {
                insertText = ", " + wildcardText;
            }
            
            // Insert at cursor position
            const newText = cursorPos !== undefined && cursorPos >= 0
                ? currentText.substring(0, cursorPos) + insertText + currentText.substring(cursorPos)
                : currentText + insertText;
            
            templateInput.value = newText;
            
            // Update cursor position
            if (cursorPos !== undefined) {
                templateInput.focus();
                templateInput.selectionStart = cursorPos + insertText.length;
                templateInput.selectionEnd = cursorPos + insertText.length;
            }
            
            // Update preview
            updatePromptPreview();
        }
        
        // Add a generic wildcard to the template at cursor position
        function addWildcardToTemplate(wildcardName = null) {
            const templateInput = document.getElementById('template-input');
            const cursorPos = templateInput.selectionStart;
            const currentText = templateInput.value;
            
            console.log("In addWildcardToTemplate, received wildcardName:", wildcardName);
            
            // Just use the generic [W] wildcard
            const wildcardContent = "[W]";
            
            // Format with commas based on position  
            let insertText;
            if (cursorPos === 0) {
                insertText = wildcardContent + ", ";
            } else {
                insertText = ", " + wildcardContent;
            }
            
            console.log("Text to insert:", insertText);
            
            // Insert at cursor position
            const newText = cursorPos !== undefined && cursorPos >= 0
                ? currentText.substring(0, cursorPos) + insertText + currentText.substring(cursorPos)
                : currentText + insertText;
            
            templateInput.value = newText;
            
            // Update cursor position
            if (cursorPos !== undefined) {
                templateInput.focus();
                templateInput.selectionStart = cursorPos + insertText.length;
                templateInput.selectionEnd = cursorPos + insertText.length;
            }
            
            // Update preview
            updatePromptPreview();
        }
        
        // Parse template to find variable placeholders
        function parseTemplate(template) {
            const regex = /\[(.*?)\]/g;
            const variables = [];
            let match;
            
            while ((match = regex.exec(template)) !== null) {
                variables.push({
                    fullMatch: match[0],
                    name: match[1],
                    position: match.index,
                    // Check if the variable name is a known wildcard
                    isNamedWildcard: Object.keys(wildcards).includes(match[1])
                });
            }
            
            return variables;
        }
        
        // Update the prompt preview with dropdowns
        function updatePromptPreview() {
            const template = document.getElementById('template-input').value;
            const previewElement = document.getElementById('prompt-preview');
            const variables = parseTemplate(template);
            
            if (variables.length === 0) {
                previewElement.textContent = template;
                return;
            }
            
            let htmlContent = '';
            let lastIndex = 0;
            
            variables.forEach((variable, index) => {
                // Add text before the variable
                htmlContent += template.substring(lastIndex, variable.position);
                
                // Add dropdown for the variable
                htmlContent += createDropdown(`variable-${index}`, variable.name, variable.isNamedWildcard);
                
                lastIndex = variable.position + variable.fullMatch.length;
            });
            
            // Add remaining text after the last variable
            htmlContent += template.substring(lastIndex);
            
            previewElement.innerHTML = htmlContent;
            
            // Add event listeners to all the new dropdowns
            document.querySelectorAll('.prompt-preview select').forEach(dropdown => {
                dropdown.addEventListener('change', () => {
                    // Auto-update the generated prompt when dropdown changes
                    const finalPrompt = generatePrompt();
                    if (document.getElementById('output-container').classList.contains('hidden') === false) {
                        displayOutput(finalPrompt);
                    }
                });
            });
            
            // Auto-update the generated prompt
            const finalPrompt = generatePrompt();
            if (document.getElementById('output-container').classList.contains('hidden') === false) {
                displayOutput(finalPrompt);
            }
        }
        
        // Create a dropdown for variable selection
        function createDropdown(id, variableName, isNamedWildcard) {
            // If this is a named wildcard (e.g. [animals]), use that wildcard and disable the dropdown
            if (isNamedWildcard) {
                let html = `<select id="${id}" data-variable="${variableName}" disabled>`;
                html += `<option value="${variableName}" selected>${variableName}</option>`;
                html += '</select>';
                return html;
            }
            
            // Otherwise, create a normal dropdown
            let html = `<select id="${id}" data-variable="${variableName}">`;
            
            Object.keys(wildcards).forEach(wildcard => {
                html += `<option value="${wildcard}">${wildcard}</option>`;
            });
            
            html += '</select>';
            return html;
        }
        
        // Generate a final prompt
        function generatePrompt() {
            const template = document.getElementById('template-input').value;
            const variables = parseTemplate(template);
            
            let finalPrompt = template;
            
            // Process variables in reverse order to avoid position shifting
            for (let i = variables.length - 1; i >= 0; i--) {
                const variable = variables[i];
                const dropdown = document.getElementById(`variable-${i}`);
                
                if (dropdown) {
                    const selectedWildcard = dropdown.value;
                    const wildcardItems = wildcards[selectedWildcard];
                    
                    if (wildcardItems && wildcardItems.length > 0) {
                        const randomIndex = Math.floor(Math.random() * wildcardItems.length);
                        const randomValue = wildcardItems[randomIndex];
                        
                        finalPrompt = finalPrompt.substring(0, variable.position) + 
                                     randomValue + 
                                     finalPrompt.substring(variable.position + variable.fullMatch.length);
                    }
                }
            }
            
            return finalPrompt;
        }
        
        // Display the generated prompt
        function displayOutput(text) {
            const outputContainer = document.getElementById('output-container');
            const outputText = document.getElementById('output-text');
            
            outputText.textContent = text;
            outputContainer.classList.remove('hidden');
        }
        
        // Copy text to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                const copyBtn = document.getElementById('copy-btn');
                const originalText = copyBtn.textContent;
                
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }
        
        // Add [W] wildcard to template
        function addWildcardToTemplate() {
            const templateInput = document.getElementById('template-input');
            const cursorPos = templateInput.selectionStart;
            const currentText = templateInput.value;
            
            // Text to insert (with comma and space)
            const insertText = ", [W]";
            
            // Insert ", [W]" at cursor position or append to end
            const newText = cursorPos !== undefined && cursorPos >= 0
                ? currentText.substring(0, cursorPos) + insertText + currentText.substring(cursorPos)
                : currentText + insertText;
            
            templateInput.value = newText;
            
            // Update the cursor position and focus the textarea
            if (cursorPos !== undefined) {
                templateInput.focus();
                templateInput.selectionStart = cursorPos + insertText.length;
                templateInput.selectionEnd = cursorPos + insertText.length;
            }
            
            // Update the preview
            updatePromptPreview();
        }
        
        // Randomize dropdowns selections
        function randomizeWildcards() {
            const dropdowns = document.querySelectorAll('.prompt-preview select:not([disabled])');
            const wildcardKeys = Object.keys(wildcards);
            
            if (wildcardKeys.length === 0) {
                console.warn('No wildcards available for randomization');
                return;
            }
            
            dropdowns.forEach(dropdown => {
                const randomIndex = Math.floor(Math.random() * wildcardKeys.length);
                dropdown.value = wildcardKeys[randomIndex];
            });
            
            // Auto-update the generated prompt after randomization
            const finalPrompt = generatePrompt();
            if (document.getElementById('output-container').classList.contains('hidden') === false) {
                displayOutput(finalPrompt);
            }
        }
        
        // Event Listeners
        // Save prompt to Day One
        function saveToJournal(promptText) {
            if (!promptText) {
                console.error('No prompt text provided');
                return;
            }
            
            // Format the prompt as a markdown code block with proper escaping
            const formattedPrompt = "\\`\\`\\`\n" + promptText + "\n\\`\\`\\`";
            
            // Create the command with hardcoded values for Journal and Tag
            const command = `dayone2 new "${formattedPrompt}" --journal="Image Prompts" --tags "Image Prompt"`;
            
            // Send the command to the server
            fetch('/save-to-dayone', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ command: command })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to save to Day One');
                }
                return response.json();
            })
            .then(data => {
                // Show success message
                const saveBtn = document.getElementById('save-to-dayone-btn');
                const originalText = saveBtn.textContent;
                
                saveBtn.textContent = 'Saved!';
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                }, 2000);
                
                // If Day One URL is returned, open it
                if (data.openUrl) {
                    window.location.href = data.openUrl;
                }
            })
            .catch(error => {
                console.error('Error saving to Day One:', error);
                alert('Failed to save to Day One: ' + error.message);
            });
        }

        // Store loaded template data
        let templateData = {};
        let currentTemplateFile = '';
        let currentTemplateIndex = 0;
        
        // Load template files from the server
        async function loadTemplates() {
            try {
                console.log('Fetching template files...');
                const response = await fetch('/templates');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const contentType = response.headers.get('content-type');
                console.log('Response content type:', contentType);
                
                const files = await response.json();
                console.log('Received template files:', files);
                
                const selector = document.getElementById('template-selector');
                console.log('Template selector element:', selector);
                
                // Clear existing options (except the first default option)
                while (selector.options.length > 1) {
                    selector.remove(1);
                }
                
                // Add template files to the dropdown
                if (Array.isArray(files) && files.length > 0) {
                    files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file.replace('.txt', '');
                        selector.appendChild(option);
                        console.log('Added template option:', file);
                    });
                } else {
                    console.warn('No template files found or files is not an array:', files);
                }
                
                console.log('Loaded template files:', files);
            } catch (error) {
                console.error('Error loading templates:', error.message);
                console.error('Stack trace:', error.stack);
            }
        }
        
        // Load a specific template file and display the first template
        async function loadTemplateFile(filename) {
            console.log('Loading template file:', filename);
            
            if (!filename) {
                // Clear the navigation if no template is selected
                document.getElementById('template-navigation').innerHTML = '';
                return;
            }
            
            try {
                console.log(`Fetching template file: /templates/${filename}`);
                const response = await fetch(`/templates/${filename}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const contentType = response.headers.get('content-type');
                console.log('Response content type:', contentType);
                
                const data = await response.json();
                console.log('Template file data:', data);
                
                // Store the template data
                templateData = data;
                currentTemplateFile = filename;
                currentTemplateIndex = 0;
                
                // Display template navigation numbers
                updateTemplateNavigation(data.lines.length);
                
                // Load the first template
                if (data.lines && data.lines.length > 0) {
                    loadTemplateAtIndex(0);
                } else {
                    console.warn('No template lines found in:', data);
                }
                
                console.log(`Loaded template file ${filename} with ${data.lines ? data.lines.length : 0} templates`);
            } catch (error) {
                console.error(`Error loading template file ${filename}:`, error.message);
                console.error('Stack trace:', error.stack);
                
                // Display an error message
                const navigation = document.getElementById('template-navigation');
                navigation.innerHTML = `<div class="error-message">Error loading template: ${error.message}</div>`;
            }
        }
        
        // Update template navigation numbers
        function updateTemplateNavigation(count) {
            const navigation = document.getElementById('template-navigation');
            navigation.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const numberBtn = document.createElement('span');
                numberBtn.className = 'template-number';
                numberBtn.textContent = (i + 1).toString();
                numberBtn.dataset.index = i;
                
                // Highlight the active template
                if (i === currentTemplateIndex) {
                    numberBtn.classList.add('active');
                }
                
                // Add click handler
                numberBtn.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    loadTemplateAtIndex(index);
                });
                
                navigation.appendChild(numberBtn);
            }
        }
        
        // Load a template at a specific index
        function loadTemplateAtIndex(index) {
            if (!templateData.lines || index >= templateData.lines.length) {
                return;
            }
            
            // Update the current template index
            currentTemplateIndex = index;
            
            // Update the template input field
            const templateInput = document.getElementById('template-input');
            templateInput.value = templateData.lines[index];
            
            // Update the preview
            updatePromptPreview();
            
            // Update the active navigation button
            document.querySelectorAll('.template-number').forEach(btn => {
                if (parseInt(btn.dataset.index) === index) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            console.log(`Loaded template at index ${index}: ${templateData.lines[index]}`);
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            // Load wildcards when page loads
            loadWildcards();
            
            // Load template files
            loadTemplates();
            
            // Template selector change handler
            document.getElementById('template-selector').addEventListener('change', function() {
                loadTemplateFile(this.value);
            });
            
            // Debug templates button click handler
            document.getElementById('debug-templates-btn').addEventListener('click', async function() {
                try {
                    // Add sample templates directly to the dropdown for testing
                    const selector = document.getElementById('template-selector');
                    
                    // Clear existing options (except the first default option)
                    while (selector.options.length > 1) {
                        selector.remove(1);
                    }
                    
                    // Add hardcoded sample templates for debugging
                    const debugTemplates = ['sample.txt', 'AAPROMPTS.txt', 'manakula.txt'];
                    
                    debugTemplates.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file.replace('.txt', '');
                        selector.appendChild(option);
                        console.log('Added debug template option:', file);
                    });
                    
                    // Show a notification
                    const navigation = document.getElementById('template-navigation');
                    navigation.innerHTML = '<div class="success-message">Added sample templates for debugging</div>';
                    
                    console.log('Added debug template files to dropdown');
                    
                    // Add direct loading function that bypasses API
                    selector.addEventListener('change', async function() {
                        const selectedFile = this.value;
                        if (!selectedFile) return;
                        
                        try {
                            // Hardcoded template content for demo purposes
                            let templateLines = [];
                            
                            if (selectedFile === 'sample.txt') {
                                templateLines = [
                                    "a beautiful [animal] in [weather], [setting], [artists]",
                                    "a beautiful [animal] in [weather], [setting], [artists], [material], [color]"
                                ];
                            } else if (selectedFile === 'AAPROMPTS.txt') {
                                templateLines = [
                                    "a beautiful [zoom][medium], topography, mountain range, aerial perspective, atmospheric depth, layers, organic, sparkles, an ultrafine hyperdetailed, white background,[artists],[color],[objects]",
                                    "a beautiful [zoom][medium] of Hawaii, stunningly beautiful paradise, lush green valley, vibrant blue waters, golden sandy beaches, majestic mountains, dotted with cascading waterfalls, framed by towering palm trees, koa trees, bright sunshine, bright vibrant hues of nature, culture and vibrant nightlife, [artists], [color], [objects]",
                                    "a beautiful [zoom][medium] of Hawaii, enchanting paradise, lush green jungle, clear turquoise waters, bright white sand beaches, sunset, night sky, illuminated, tiki torches, twinkling lights, cozy and romantic atmosphere, flickering flames of the torches cast a warm and inviting glow, lights add a sparkle of magic to the night, stunning natural beauty, [artists], [color], [objects]"
                                ];
                            } else if (selectedFile === 'manakula.txt') {
                                templateLines = [
                                    "a beautiful [animal], symmetrical, graceful, elegant, sophisticated, pine trees, aspen trees, bright colors, colorful, marijuana leaves, butterflies, Flourishing, full color spectrums, global illumination, radiant light, detailed and intricate environment, detailed lace underwear, summer forest, lush mountains, modern, spirit, lake, stars, campfire, flourishing, antlers, joyous, cozy, lights, fireflies, moose, birds, flock, steaming,"
                                ];
                            }
                            
                            // Update UI
                            updateTemplateNavigation(templateLines.length);
                            
                            // Store template data
                            templateData = {
                                filename: selectedFile,
                                lines: templateLines
                            };
                            currentTemplateFile = selectedFile;
                            currentTemplateIndex = 0;
                            
                            // Load the first template
                            if (templateLines.length > 0) {
                                loadTemplateAtIndex(0);
                            }
                            
                            console.log(`Loaded hardcoded template file ${selectedFile} with ${templateLines.length} templates`);
                        } catch (error) {
                            console.error('Error in direct template loading:', error);
                            navigation.innerHTML = `<div class="error-message">Error loading template: ${error.message}</div>`;
                        }
                    });
                } catch (error) {
                    console.error('Error in debug templates function:', error);
                }
            });
            
            // Update preview when template changes
            document.getElementById('template-input').addEventListener('input', updatePromptPreview);
            
            // Generate button click handler
            document.getElementById('generate-btn').addEventListener('click', () => {
                const finalPrompt = generatePrompt();
                displayOutput(finalPrompt);
            });
            
            // Copy button click handler
            document.getElementById('copy-btn').addEventListener('click', () => {
                const text = document.getElementById('output-text').textContent;
                copyToClipboard(text);
            });
            
            // Save to Day One button click handler
            document.getElementById('save-to-dayone-btn').addEventListener('click', () => {
                const text = document.getElementById('output-text').textContent;
                saveToJournal(text);
            });
            
            // Add Wildcard button click handler
            document.getElementById('add-wildcard-btn').addEventListener('click', () => {
                // Call with null to use the default [W] wildcard
                addWildcardToTemplate(null);
            });
            
            // Randomize button click handler
            document.getElementById('randomize-btn').addEventListener('click', randomizeWildcards);
        });
    </script>
</body>
</html>